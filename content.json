[{"title":"Java Concurrency Perspective Inter-thread Communication（三）Java并发透视之线程间通信","date":"2017-08-17T09:30:31.000Z","path":"posts/java/concurrency/java-concurrency-perspective-003-inter-threads-communication.html","text":"If you are aware of interprocess communication then it will be easy for you to understand interthread communication. Interthread communication is important when you develop an application where two or more threads exchange some information. There are three simple methods and a little trick which makes thread communication possible. All the three methods are listed below","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://asion.club/categories/java/"},{"name":"concurrency","slug":"java/concurrency","permalink":"http://asion.club/categories/java/concurrency/"}],"tags":[{"name":"java","slug":"java","permalink":"http://asion.club/tags/java/"},{"name":"concurrency","slug":"concurrency","permalink":"http://asion.club/tags/concurrency/"}]},{"title":"Java Concurrency Perspective Major Operations (二) </br> Java 并发透视之主要操作","date":"2017-08-17T06:00:01.000Z","path":"posts/java/concurrency/java-concurrency-perspective-002-major-operations.html","text":"Java 并发透视之主要操作（二）java 多线程的主要操作 方法 简介 sleep(long) 该方法使当前线程睡眠一定时间，单位为毫秒（ms） getPriority() 该方法可以获取线程的优先级 setPriority(int) 该方法设置线程的优先级，但是并不能保证按这个优先级优先运行 yield() 该方法让出CUP资源，让其他线程先执行 join() 该方法合并一个线程到当前线程 wait() 当前线程等待其他线程调用notify()后才会继续运行 notify() 该方法唤醒一个等待中的线程 notifyAll() 该方法所有正在等待的线程 sleep()该方法使当前线程睡眠一定时间，单位为毫秒（ms）还是上一节的例子，但是我们在run()方法的循环体中添加了 Thread.sleep(50); 语句。这样输出的结果就是，Thread-1：倒计时一次，Thread-2：倒计时一次。12345678910111213141516171819202122232425262728Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 10Running Thread-2Thread: Thread-2, 10Thread: Thread-2, 9Thread: Thread-1, 9Thread: Thread-2, 8Thread: Thread-1, 8Thread: Thread-2, 7Thread: Thread-1, 7Thread: Thread-1, 6Thread: Thread-2, 6Thread: Thread-2, 5Thread: Thread-1, 5Thread: Thread-2, 4Thread: Thread-1, 4Thread: Thread-2, 3Thread: Thread-1, 3Thread: Thread-2, 2Thread: Thread-1, 2Thread: Thread-2, 1Thread: Thread-1, 1Thread Thread-2 exiting.Thread Thread-1 exiting. 因为，循环每执行一次，线程就睡眠50毫秒，所以，使得倒计时比较均匀。Thread-1倒计时一次，然后，Thread-2倒计时一次。 demo code： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768package io.asion.concurrent;import org.junit.Test;/** * 实现Runnable接口的方式，创建线程 * * @author Asion * @since 2017/03/24 */class RunnableDemo implements Runnable &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; /** * 构造一个Runnable实例 * * @param name 线程名称 */ RunnableDemo(String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(\"Running \" + threadName); try &#123; for (int i = 10; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); Thread.sleep(50); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; /** * 普通start()方法 */ void start() &#123; System.out.println(\"Starting \" + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用线程类的start()方法，启动线程 t.start(); &#125; &#125;&#125;public class TestRunnableSleep &#123; // 启动两个线程测试 @Test public void testRunnableSleep() &#123; RunnableDemo r1 = new RunnableDemo(\"Thread-1\"); r1.start(); RunnableDemo r2 = new RunnableDemo(\"Thread-2\"); r2.start(); &#125;&#125; setPriority(int) &amp; getPriority()getPriority()方法可以获取该线程的优先级setPriority(int)方法设置线程的优先级，但是JVM并不能保证按这个优先级优先运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package io.asion.concurrent;import org.junit.Test;/** * 实现Runnable接口的方式，创建线程 * * @author Asion * @since 2017/03/24 */class PriorityDemo implements Runnable &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; /** * 构造一个Runnable实例 * * @param name 线程名称 */ PriorityDemo(String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(\"Running \" + threadName); try &#123; for (int i = 100; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); Thread.sleep(50); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; /** * 普通start()方法 */ void start() &#123; System.out.println(\"Starting \" + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用线程类的start()方法，启动线程 t.start(); &#125; &#125; void start(Thread t) &#123; this.t = t; this.t.start(); &#125;&#125;public class TestPriority &#123; // 启动两个线程测试 @Test public void testPriority() &#123; PriorityDemo r1 = new PriorityDemo(\"Thread-1\"); Thread thread = new Thread(r1, \"Thread-1\"); thread.setPriority(Thread.MIN_PRIORITY); r1.start(thread); PriorityDemo r2 = new PriorityDemo(\"Thread-2\"); Thread thread1 = new Thread(r1, \"Thread-2\"); System.out.println(thread1.getPriority()); r2.start(); &#125;&#125; yield()Thread.yield()给其他线程让出CUP资源，让其他线程先执行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778package io.asion.concurrent;import org.junit.Test;/** * @author Asion. * @since 2017/4/5. */public class TestYield &#123; // 启动两个线程测试 @Test public void testYield() &#123; YieldDemo r1 = new YieldDemo(&quot;Thread-1&quot;); r1.start(); YieldDemo r2 = new YieldDemo(&quot;Thread-2&quot;); r2.start(); &#125;&#125;/** * 实现Runnable接口的方式，创建线程 * * @author Asion * @since 2017/03/24 */class YieldDemo implements Runnable &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; /** * 构造一个Runnable实例 * * @param name 线程名称 */ YieldDemo(String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(&quot;Running &quot; + threadName); for (int i = 10; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); // 只要碰到10的倍数就让给其他线程执行 if (i % 2 == 0) &#123; Thread.yield(); System.out.println(&quot;Thread: &quot; + threadName + &quot;, yield&quot;); &#125; &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; /** * 普通start()方法 */ void start() &#123; System.out.println(&quot;Starting &quot; + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用线程类的start()方法，启动线程 t.start(); &#125; &#125; void start(Thread t) &#123; this.t = t; t.start(); &#125;&#125; 例子中，只要碰到2的倍数就让给其他线程执行 输出的结果:12345678910111213141516171819202122232425262728293031323334353637383940Creating Thread-1Starting Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 10Running Thread-2Thread: Thread-2, 10Thread: Thread-1, yieldThread: Thread-1, 9Thread: Thread-1, 8Thread: Thread-2, yieldThread: Thread-2, 9Thread: Thread-2, 8Thread: Thread-1, yieldThread: Thread-1, 7Thread: Thread-1, 6Thread: Thread-2, yieldThread: Thread-2, 7Thread: Thread-2, 6Thread: Thread-1, yieldThread: Thread-1, 5Thread: Thread-1, 4Thread: Thread-2, yieldThread: Thread-2, 5Thread: Thread-2, 4Thread: Thread-1, yieldThread: Thread-1, 3Thread: Thread-1, 2Thread: Thread-2, yieldThread: Thread-2, 3Thread: Thread-2, 2Thread: Thread-1, yieldThread: Thread-1, 1Thread Thread-1 exiting.Thread: Thread-2, yieldThread: Thread-2, 1Thread Thread-2 exiting.Process finished with exit code 0 join()join 例子:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990package io.asion.concurrent;import org.junit.Test;/** * @author Asion. * @since 2017/4/9. */public class TestJoin &#123; // 启动两个线程测试 @Test public void testJion() &#123; JoinDemo r1 = new JoinDemo(&quot;Thread-1&quot;); Thread thread = new Thread(r1, &quot;Thread-1&quot;); r1.start(thread); JoinDemo r2 = new JoinDemo(&quot;Thread-2&quot;); r2.start(); r1.join(); r2.join(); for (int i = 10; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: main&quot; + Thread.currentThread().getId() + &quot;, &quot; + i); &#125; System.out.println(&quot;Thread main&quot; + Thread.currentThread().getId() + &quot; finish.&quot;); &#125;&#125;/** * 实现Runnable接口的方式，创建线程 * * @author Asion * @since 2017/03/24 */class JoinDemo implements Runnable &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; /** * 构造一个Runnable实例 * * @param name 线程名称 */ JoinDemo(String name) &#123; threadName = name; System.out.println(&quot;Creating &quot; + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(&quot;Running &quot; + threadName); for (int i = 10; i &gt; 0; i--) &#123; System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i); &#125; System.out.println(&quot;Thread &quot; + threadName + &quot; exiting.&quot;); &#125; /** * 普通start()方法 */ void start() &#123; System.out.println(&quot;Starting &quot; + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用线程类的start()方法，启动线程 t.start(); &#125; &#125; void start(Thread t) &#123; this.t = t; t.start(); &#125; void join() &#123; try &#123; this.t.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 例子中，r1、r2两个线程都调用了join(),所以main线程必须等待r1、r2线程执行完成，才可以往下执行。 输出结果:1234567891011121314151617181920212223242526272829303132333435363738Creating Thread-1Creating Thread-2Starting Thread-2Running Thread-1Thread: Thread-1, 10Thread: Thread-1, 9Thread: Thread-1, 8Thread: Thread-1, 7Thread: Thread-1, 6Thread: Thread-1, 5Thread: Thread-1, 4Thread: Thread-1, 3Thread: Thread-1, 2Thread: Thread-1, 1Thread Thread-1 exiting.Running Thread-2Thread: Thread-2, 10Thread: Thread-2, 9Thread: Thread-2, 8Thread: Thread-2, 7Thread: Thread-2, 6Thread: Thread-2, 5Thread: Thread-2, 4Thread: Thread-2, 3Thread: Thread-2, 2Thread: Thread-2, 1Thread Thread-2 exiting.Thread: main1, 10Thread: main1, 9Thread: main1, 8Thread: main1, 7Thread: main1, 6Thread: main1, 5Thread: main1, 4Thread: main1, 3Thread: main1, 2Thread: main1, 1Thread main1 finish. wait() &amp; notify()/notifyAll()","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://asion.club/categories/java/"},{"name":"concurrency","slug":"java/concurrency","permalink":"http://asion.club/categories/java/concurrency/"}],"tags":[{"name":"java","slug":"java","permalink":"http://asion.club/tags/java/"},{"name":"concurrency","slug":"concurrency","permalink":"http://asion.club/tags/concurrency/"}]},{"title":"Java Concurrency Perspective Overview (一) </br> Java 并发透视之初窥探（一）","date":"2017-08-17T04:07:01.000Z","path":"posts/java/concurrency/java-concurrency-perspective-001-overview.html","text":"Java 并发透视之初窥探（一）概述Java是一种支持多线程编程的语言，意味着，我们可以使用Java开发多线程程序。一个多线程程序包含两个或多个可以同时运行的部件，每个部件可以同时处理不同的任务，特别是当计算机有多个CPU时，可以有效地利用可用资源。多任务是指多个进程共享共同的处理资源，如CPU。多线程将多任务的概念扩展到可以将单个应用程序中的特定操作细分为单个线程的应用程序。每个线程可以并行运行。OS不仅在不同的应用程序之间划分处理时间，而且在应用程序中的每个线程之间划分处理时间。多线程使您能够以同一程序同时进行多个活动的方式进行写入。 线程的生命周期线程生命周期经历了几个阶段：线程诞生，启动，运行，阻塞，死亡。下图简要显示了一个线程的完整生命周期。 +-------------+ start() \\=-------------=/ new Thread()--&gt;| New |------------&gt;\\ Runnable /&lt;---------+ +------+------+ \\-----+-----/ | | | | | |run() | v End of v | +------+------+ execution /------+-------\\ | End&lt;--\\ Dead /&lt;------------| Running | | -------+------- \\------+-------/ | Release Block ^ | | | |sleep(), wait() | | =-------------= | | +------| Blocked |&lt;-----+ | =------+------= | | | | | +-------------------------------+ Life cycle of a Thread ----------------------------- 以下是生命周期的各个阶段简述： 新的（New） - 新线程在新的状态下开始其生命周期。直到程序启动线程为止，它保持在这种状态。它也被称为新生线程。 可运行的（Runnable） - 新诞生的线程启动后，该线程可以运行。该状态的线程被认为正在执行其任务。但是，可能还未正式运行，可能在等待资源，如：CPU。 运行中的（Running） - 新诞生的线程启动后，如果，所有的准备条件已经满足，该线程会从准备运行状态进入运行状态，执行任务。 等待（Waiting） - 有时线程会转换到等待状态，而线程等待另一个线程执行任务。只有当另一个线程发信号通知等待线程才能继续执行时，线程才转回到可运行状态。 定时等待（Timed Waiting） - 可运行的线程可以在指定的时间间隔内进入定时等待状态。当该时间间隔到期或发生等待的事件时，此状态的线程将转换回可运行状态。 终止（Dead） - 可执行线程在完成任务或以其他方式终止时进入终止状态。 线程的优先级每一个线程都有一个优先级，可以帮助操作系统确定安排线程的顺序。 Java线程优先级在MIN_PRIORITY（常量为1）和MAX_PRIORITY（常量为10）之间的范围内。默认情况下，每个线程都被赋予优先级NORM_PRIORITY（常量为5）。 具有较高优先级的线程对于一个程序来说更重要，应该在低优先级线程之前分配处理器时间。然而，线程优先级不能保证线程执行的顺序，并且依赖于平台。 创建自己的第一个线程Java主要可以通过两种方式创建多线程的程序： 1.通过实现Runnable接口创建一个线程（推荐使用）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 实现Runnable接口的方式，创建线程 * * @author Asion * @since 2017/03/24 */class RunnableDemo implements Runnable &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; /** * 构造一个Runnable实例 * * @param name 线程名称 */ RunnableDemo(String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(\"Running \" + threadName); for (int i = 100; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; /** * 普通start()方法 */ void start() &#123; System.out.println(\"Starting \" + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用线程类的start()方法，启动线程 t.start(); &#125; &#125;&#125;public class TestRunnable &#123; // 启动两个线程测试 public static void main(String args[]) &#123; RunnableDemo r1 = new RunnableDemo(\"Thread-1\"); r1.start(); RunnableDemo r2 = new RunnableDemo(\"Thread-2\"); r2.start(); &#125;&#125; 2.通过继承Thread类创建一个线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 继承Thread类，创建线程 * * @author Asion * @since 2017/03/24 */class ThreadDemo extends Thread &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; ThreadDemo(String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(\"Running \" + threadName); for (int i = 100; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; /** * 重写父类的start()方法 * 谨慎重写父类的start()方法 */ @Override public void start() &#123; System.out.println(\"Starting \" + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用父类的start()方法，启动线程 t.start(); &#125; &#125;&#125;public class TestThread &#123; // 启动两个线程测试 public static void main(String args[]) &#123; ThreadDemo t1 = new ThreadDemo(\"Thread-1\"); t1.start(); ThreadDemo t2 = new ThreadDemo(\"Thread-2\"); t2.start(); &#125;&#125; 我们来简单分析一下多线程的程序 首先，我们的RunnableDemo实现的Runnable接口，那必须重写run()方法，run()就是线程running运行的方法，是线程体。 当new一个Thread实例，传入我们的RunnableDemo实例，这时线程生命周期处在新建（new）阶段； 然后，当调用Thread实例的start()方法时，说明线程已经准备就绪，转到了就绪（Runnable）状态； 如果此时，分配到了CPU，调用了run()方法开始执行，就转到运行（Running）状态； 当run()方法运行结束，线程就结束；或者run()方法中异常导致线程结束退出。 通过这一小节我们，我们了解java线程的创建和启动。下一节我们来看看java多线程的主要操作。","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://asion.club/categories/java/"},{"name":"concurrency","slug":"java/concurrency","permalink":"http://asion.club/categories/java/concurrency/"}],"tags":[{"name":"java","slug":"java","permalink":"http://asion.club/tags/java/"},{"name":"concurrency","slug":"concurrency","permalink":"http://asion.club/tags/concurrency/"}]},{"title":"（九）Docker docker-compose","date":"2017-05-24T10:11:18.000Z","path":"posts/docker/docker-009-docker-compose.html","text":"Docker Compose1.什么是Docker Compose？编排和配置容器集群的工具。 编排：定义被部署的对象的各组成部分之间的耦合关系，部署流程中各个动作的执行顺序，部署过程所需要的依赖文件和被部署文件的存储位置和获取方式，以及如何验证部署成功。这些信息都会在编排工具中以指定的格式定义并保存下来，从而保证这个流程可以在新的环境中快速的复现。 2.Docker Compose安装下载docker-compose 二进制文件 curl -L https://github.com/docker/compose/releases/download/1.8.0/docker-compose-`uname -s-uname -m` &gt; /usr/local/bin/docker-compose &amp;&amp; chmod +x /usr/local/bin/docker-compose 黑魔法： 下载地址： https://github.com/docker/compose/releases 3.Docker Compose使用入门准备环境 1） 创建测试项目文件夹123mkdir composetestcd composetest 2） 编辑app.py并保存12345678910111213141516171819from flask import Flaskfrom redis import Redisapp = Flask(__name__)redis = Redis(host=&apos;redis&apos;, port=6379)@app.route(&apos;/&apos;)def hello():redis.incr(&apos;hits&apos;)return &apos;Hello World! I have been seen %s times.&apos; % redis.get(&apos;hits&apos;)if __name__ == &quot;__main__&quot;:app.run(host=&quot;0.0.0.0&quot;, debug=True) 3） 在项目目录创建requirements.txt并保存 flask redis 利用dockerfile创建docker镜像 1234567891011FROM python:2.7ADD . /codeWORKDIR /codeRUN pip install -r requirements.txtCMD python app.pydocker build -t web . 定义服务 创建docker-compose.yml文件 Compose文件定义了2个服务，web和redis。 Web服务： 从当前目录下的dockerfile创建 容器的5000端口与宿主机5000端口绑定 将项目目录与容器内的/code目录绑定 web服务与redis服务建立连接 通过compose运行app服务 1docker-compose up 备注： docker-compose up –d （后台启动） docker-compose stop （停止运行） Compose命令集： https://docs.docker.com/compose/reference/","excerpt":"","categories":[],"tags":[]},{"title":"（八）Docker Dockerfile","date":"2017-05-24T10:07:23.000Z","path":"posts/docker/docker-008-dockerfile.html","text":"Dockerfile1.利用Dockerfile创建镜像什么是Dockerfile？ 定义：Dockerfile是一个文本格式的配置文件，用户可以使用Dockerfile快速创建自定义镜像。 基本结构： Dockerfile由一行行的命令语句组成。并且支持以#开头的注释行。一般Dockerfile分为四个部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时的指令。 Dockerfile示例: #This is a Dockerfile #Author:chen #第一行必须指定基础镜像 FROM ubuntu #维护者信息 MAINTAINER &#x63;&#x68;&#x65;&#110;&#x40;&#x64;&#x61;&#x6a;&#x69;&#97;&#x6e;&#103;&#x74;&#x61;&#105;&#x2e;&#x63;&#x6f;&#x6d; #镜像的操作指令 RUN apt-get update &amp;&amp; apt-get install –y nginx docker run -d -p 127.0.0.1::3306 –name mysql mysql:5.6 RUN echo “\\ndaemon off” &gt;&gt; /etc/nginx/nginx.conf #容器启动时的指令 CMD /usr/sbin/nginx 操作一下： 首先创建目录testDockerfile并进入 vi Dockerfile 创建命令： docker build –t =“&lt;镜像名称&gt;” . 注意：执行此命令要和Dockerfile在同级目录，文件名称必须为Dockerfile。命令后面的”.”表示在当前目录下执行。 2．Dockerfile指令集1 FROM 格式为 FROM 或:。 第一条指令必须为FROM指令，用于指定基础镜像。 2 MAINTAINER 格式为 MAINTAINER ,指定维护者信息。 3 RUN 格式为 RUN ,会在shell终端运行命令。 4 EXPOSE 格式为 EXPOSE [ …],容器需要暴露的端口号。镜像启动可以通过 –P 或 -p 进行端口映射的绑定。 5 ENV 格式为 ENV 。 指定一个环境变量，可以被后续的RUN引用，并且在容器中记录该环境变量。 6 ADD 格式为 ADD 。 该命令将复制指定的到容器中的。其中可以是Dockerfile所在目录的一个相对路径；也可以是url，还可以是tar文件（自动解压）。 7 VOLUME 格式为 VOLUME [path]。 创建一个可以从本地主机或其他容器挂载点，一般用来存放需要保持的数据。 8 USER 格式为 USER 。 指定运行容器时的用户名，后续的RUN也会指定该用户。 9 WORKDIR 格式为 WORKDIR 。 指定工作空间，运行完WORKDIR后，后续执行的RUN、CMD、ENTRYPOINT都会在此目录下执行。 10 COPY 格式为 COPY 。 复制本地主机的到容器中的,目标路径不存在时，会自动创建。 当使用本地目录为源目录时，推荐使用COPY。 11 CMD 推荐格式为 CMD [“executable”,”param1”,”param2”] 。 作为ENTRYPOINT的默认参数为 CMD［”param1”,”param2”］。 指定容器的启动命令，每个Dockerfile只能有一条CMD命令，如果指定多条，只有最后一条会执行。 用户启动容器时指定运行命令，会覆盖掉Dockerfile中的CMD命令。 12 ENTRYPOINT 格式为 ENTRYPOINT [“executable”,”param1”,”param2”]。 配置容器启动后的命令，可被docker run提供的–entrypoint参数覆盖。 每个Dockerfile只能有一条ENTRYPOINT命令，如果指定多条，只有最后一条会执行。 3．Dockerfile最佳实践1 错误定位 每个Dockerfile的指令可以生成新的一层镜像，如果通过Dockerfile创建镜像出错，可以根据出错所在步骤的上一层启动容器，然后手工执行出错层的命令，以达到调试目的。 2 好的使用习惯 http://dockone.io/article/131 http://dockone.io/article/132","excerpt":"","categories":[{"name":"docker","slug":"docker","permalink":"http://asion.club/categories/docker/"}],"tags":[{"name":"docker dockerfile","slug":"docker-dockerfile","permalink":"http://asion.club/tags/docker-dockerfile/"}]},{"title":"（七）Docker Network","date":"2017-05-24T10:04:40.000Z","path":"posts/docker/docker-007-network.html","text":"Docker网络1．容器对外服务当容器内运行一些网络应用，要让外部访问这些应用时，可以通过 -P 或 -p 参数来指定端口映射。 使用 -P 映射时，Docker会随机映射一个49000 ～ 49900 的端口至容器内部开放的端口： docker run -d -P –name mysql mysql:5.6 通过docker ps可以看到端口映射关系。可以通过映射在宿主机的端口来访问对应容器内的服务。 映射到指定宿主机的端口： docker run -d -p 3306:3306 –name mysql mysql:5.6 映射到指定地址的指定端口，以127.0.0.1为例： docker run -d -p 127.0.0.1:3306:3306 –name mysql mysql:5.6 映射到指定地址的任意端口，以127.0.0.1为例： docker run -d -p 127.0.0.1::3306 –name mysql mysql:5.6 查看映射端口配置： docker port mysql 3306 2．容器间相互通信通过映射宿主机的端口实现容器的互联。 容器的连接(link)除了端口映射外的另一种可以与容器中应用进行交互的方式。 使用 –link 参数可以让容器之间安全的进行交互。 创建一个数据库容器： docker run -d –name mysqldb mysql:5.6 创建一个web容器并和数据库容器建立连接： docker run -d –name Webapp –p 8000:8080 –link mysqldb:MySQL tomcat mysqldb容器和web容器建立互联关系。 –link参数的格式为–link name:alias,其中name是要连接的容器名称，alias是这个连接的别名。 可以使用docker ps（PORT字段）来查看容器的连接。 Docker在两个容器之间创建了安全隧道，而且不用映射它们的端口到宿主机上。在启动mysqldb的时候并没有使用-p和-P标记，从而避免的了暴露数据库的端口到外部的网络上。 Docker通过两种方式为容器公开连接信息： 环境变量： 使用env命令来查看。 EX: docker run –rm –name test –link dblink:dblink ubuntu env 更新/etc/hosts文件 查看/etc/hosts文件。","excerpt":"","categories":[],"tags":[]},{"title":"（六）Docker Data Management and Volume","date":"2017-05-24T10:00:16.000Z","path":"posts/docker/docker-006-data-manager.html","text":"数据管理1.数据卷(Data Volume)数据卷是一个可供容器使用的特殊目录，有如下特性： 数据卷可以在容器之间共享和重用 数据卷修改会立即生效 数据卷的更新不会影响镜像 如果有容器使用数据卷，该卷会一直存在 在容器内创建数据卷 在使用docker run的命令时，使用 -v 标记可以在容器内创建一个数据卷，并且可以指定挂在一个本地已有的目录到容器中作为数据卷： docker run -d –name app1 -it -v ${PWD}/webapp:/root/webapp ubuntu bash 注意：默认挂载的数据卷的权限是rw（可读写），如果要求ro（只读），则需要加上对应的ro参数，命令可改为： docker run -d –name app1 -it -v ${PWD}/webapp:/root/webapp:ro ubuntu bash 下面我们一起来操作一下： 创建webapp目录，在目录下新建文件file，并在文件file中写入 “this is a file”。 echo ${PWD} 命令标识当前目录。 创建启动app1容器并挂载数据卷 进入容器找到root目录可查看到已挂载的数据卷。 数据卷目录与容器内目录有映射关系，所以不管是在容器内部修改数据卷还是在外部修改数据卷，相对应的数据卷都会发生改变。 2.数据卷容器数据卷容器用于用户需要在容器间共享一些持续更新的数据，数据卷容器专门提供数据卷供其它容器挂载使用。 Example: 创建数据卷容器db1 docker run -d –name db1 -v /dbdata -ti ubuntu bash 创建容器db2与db1共享dbdata的数据 docker run -d –name db2 –volumes-from db1 -ti ubuntu bash 在容器db1和容器db2任意一个容器修改dbdata的内容，在两个容器内均生效 数据卷容器的删除： 如果删除了挂载的容器，数据卷并不会被自动删除，如果要删除一个数据卷，必须在删除最后一个还挂载它的容器时显示使用docker rm -v 命令指定同时删除关联的容器。在下图可看到即使删除atest，btest中仍然有fileA文件。 3.利用数据卷迁移容器可以利用数据卷容器对其中的数据卷进行备份、恢复，以实现数据的迁移。 备份： 使用下面的命令来备份dbdata数据卷容器内的数据卷： docker run –volumes-from dbdata -v ${PWD}:/backup –name worker ubuntu \\tar cvf /backup/backup.tar /dbdata 说明： 利用ubuntu镜像创建一个容器worker。使用–volumes-from dbdata参数来让worker容器挂载dbdata的数据卷；使用${pwd}:/backup参数来挂载本地目录到worker容器的/backup目录。 worker启动后，使用tar命令将/dbdata下的内容备份为容器内的/backup/backup.tar。 创建dbdata数据卷容器并写入文件：fileA、fileB、fileC 执行备份命令创建备份tar包： 恢复： 如果恢复数据到一个容器，可以参照下面的操作。首先创建一个带有数据卷的容器dbdata2: docker run -d -v /dbdata –name dbdata2 ubuntu /bin/bash 然后创建另一个新的容器，挂载dbdata2的容器，并使用tar命令解压备份文件到挂载的容器卷中即可： docker run –volumes-from dbdata2 -v ${pwd}:/backup ubuntu tar xvf /backup/backup.tar","excerpt":"","categories":[],"tags":[]},{"title":"（五）Docker Repository","date":"2017-05-24T09:58:11.000Z","path":"posts/docker/docker-005-repository.html","text":"仓库(Repository)1.Docker Hub仓库是集中存放镜像的地方。 目前Docker官方仓库维护了一个公共仓库https://hub.docker.com，其中已经包括15000多个的镜像。 大部分需求都可以通过在Docker Hub中直接下来镜像来实现。 登录 可以通过执行docker login命令来输入用户名、密码和邮箱来完成注册登录。 基本操作 用户无需登录可以通过 docker search命令来查找官方仓库中的镜像，并利用docker pull 下载到本地，可以通过docker push 命令将本地镜像推送到docker hub。 2.创建和使用私有仓库创建私有仓库 使用registry镜像创建私有仓库 可以通过docker官方提供的registry镜像来搭建一套本地私有仓库。 镜像地址：https://hub.docker.com/_/registry/ 命令： docker run -e SEARCH_BACKEND=sqlalchemy -e SQLALCHEMY_INDEX_DATABASE=sqlite:////tmp/docker-registry.db -d –name registry -p 5000:5000 registry 参考地址： https://github.com/docker/docker-registry#search-engine-options https://hub.docker.com/_/registry/ 自动下载并启动一个registry容器，创建本地的私有仓库服务。 默认仓库创建在/tmp/registry目录下。 docker启动参数配置： 环境：centos7 配置文件：/lib/systemd/system/docker.service 参考地址：https://docs.docker.com/engine/admin/configuring/ 3.仓库加速服务加速下载官方镜像。 推荐服务：https://dashboard.daocloud.io/ 点击加速器：https://dashboard.daocloud.io/mirror 配置Docker加速器： 下载第三方官方仓库。 4.仓库管理Registry Web UI 用于镜像的查询，删除。 镜像地址：https://hub.docker.com/r/atcol/docker-registry-ui/ 启动命令： docker run -d –name registry_ui -p 8080:8080 -e REG1=http://:5000/v1/ atcol/docker-registry-ui 访问地址： http://:8080","excerpt":"","categories":[{"name":"docker","slug":"docker","permalink":"http://asion.club/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://asion.club/tags/docker/"}]},{"title":"（四）Docker Container Operation","date":"2017-05-24T09:45:11.000Z","path":"posts/docker/docker-004-container-operation.html","text":"容器的常用操作1．创建容器Docker的容器十分轻量级，用户可以随时创建或删除容器。 新建容器：docker create Example：docker create –ti ubuntu 说明：使用docker create命令创建的容器处于停止状态，可以使用docker start命令启动它。 新建并启动容器:docker run Example: docker run ubuntu /bin/echo “Hello World” 说明： 等价于先执行docker create命令，再执行docker start命令。 docker run 背后的故事： 1 检查本地是否存在制定的镜像，不存在就从公有仓库下载。 2 利用本地镜像创建并启动一个容器。 3 分配一个文件系统，并在只读的镜像层外面挂载一层可读写层。 4 从宿主机配置的网桥接口桥接一个虚拟接口到容器中去。 5 从地址池配置一个IP地址给容器。 6 执行用户的指定的用户程序。 7 执行完毕后容器被终止。 一条简单的命令： docker run -i –t ubuntu /bin/bash -t : 让docker分配一个伪终端并绑定到容器的标准输入上。 -i : 让容器的标准输入保持打开。 在交互模式下，用户可以通过所创建的终端来输入命令，exit命令退出容器。 退出后，容器自动处于终止状态。 守护台运行： 更多的时候，需要让Docker容器运行在后台以守护态（daemonized）形式运行。用户可以通过 添加-d参数来实现。 Example: docker run –d ubuntu /bin/sh -c “while true;do echo hello world;sleep 1;done” 补充： 查看日志： docker logs 2．终止容器可以使用docker stop命令来终止一个运行中的容器。 docker stop 注意： 当容器中的应用终结时，容器也会自动停止。 查看终止的容器：docker ps -a 查看运行的容器：docker ps 重新启动容器：docker start 3．进入容器在使用-d参数时，容器启动后会进入后台，用户无法看到容器中的信息。 docker exec Exec可以直接在容器内部运行命令。 进入容器： docker exec -i –t bash 4．删除容器可以使用docker rm命令删除终止状态的容器。 如果删除正在运行的容器，可以使用docker rm –f命令。 5．导入和导出容器导出容器是指导出一个已经创建的容器到一个文件，不管容器是否处于运行状态。可以使用docker export命令。 docker export Example: Docker export test_id &gt; test.tar 导出的文件又可以使用docker import命令导入，成为镜像。 Example: cat test.tar | docker import – dajiangtai/testimport:latest","excerpt":"","categories":[{"name":"docker","slug":"docker","permalink":"http://asion.club/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://asion.club/tags/docker/"}]},{"title":"（三）Docker Image Operation","date":"2017-05-24T09:30:11.000Z","path":"posts/docker/docker-003-image-operation.html","text":"镜像的常用操作1.获取镜像：命令： docker pull //: 说明：镜像是Docker运行容器的前提。用户可以使用docker pull 命令从网络上下载镜像。对于镜像来说，如果不显式地指定tag,则默认会选择latest标签，即下载仓库中最新版本的镜像。 例子：docker pull hub.docker.com/asion/java:8 2.查看镜像列表命令： docker images 说明：使用docker images命令可以列出本地主机上已有的镜像。信息含义：来自于哪个仓库、镜像的标签信息、镜像的ID号（唯一）、创建时间、镜像大小。 3.查看镜像信息命令： docker inspect 说明：docker inspect命令返回的是一个JSON的格式消息，如果我们只要其中的一项内容时，可以通过-f参数来指定。Image_id通常可以使用该镜像ID的前若干个字符组成的可区分字符串来替代完成的ID。 4.查找镜像命令： docker search 说明： 使用docker search命令可以搜索远端仓库中共享的镜像，默认搜索Docker hub官方仓库中的镜像。 5.删除镜像命令： docker rmi : 说明： 使用docker rmi命令可以删除镜像，其中image可以为标签或ID。 注意： 当同一个镜像拥有多个标签，docker rmi只是删除该镜像多个标签中的指定标签而已，而不影响镜像文件。 当有该镜像创建的容器存在时，镜像文件默认是无法被删除的。 6.创建镜像命令： docker commit 参数说明： -a , –author : 作者信息 -m , –meassage : 提交消息 -p , –pause=true : 提交时暂停容器运行 说明： 基于已有的镜像的容器的创建。 7.迁移镜像命令： docker save -o .tar : 参数说明： -o:设置存储压缩后的文件名称 说明： 可以使用docker save命令来迁出镜像，其中image可以为标签或ID。 8.载入镜像命令： docker load –input .tar 或 docker load &lt; .tar 说明： 使用docker load命令可以载入镜像，其中image可以为标签或ID。 这将导入镜像及相关的元数据信息（包括标签等），可以使用docker images命令进行查看。 9.上传镜像命令： docker push //: 说明： 可以使用docker push命令上传镜像到仓库，默认上传到DockerHub官方仓库（需要登录）。","excerpt":"","categories":[{"name":"docker","slug":"docker","permalink":"http://asion.club/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://asion.club/tags/docker/"}]},{"title":"（二）Docker Core Operation and Installation","date":"2017-05-24T09:10:11.000Z","path":"posts/docker/docker-002-install-core-operation.html","text":"docker的核心概念和安装docker的安装和配置环境介绍： 操作系统：64bit CentOS7 docker版本：17.04.0-ce (2017-04-05) 版本新功能：https://github.com/moby/moby/blob/master/CHANGELOG.md 安装步骤 安装准备： 要求: 内核版本最低为3.10 查看当前内核版本： uname –r 通过yum方式安装docker： 第一步：更新yum源： sudo yum update 第二步：增加docker的yum源： 输入命令：sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-‘EOF’ 输入：1234567[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF` 这样我们就添加了yum源 可以通过命令：sudo vi /etc/yum.repos.d/docker.repo 查看： 第三步：通过yum安装docker sudo yum install docker-engine 第四步：启动docker服务 sudo service docker start 第五步：查看版本信息，通过测试用例验证docker是否安装成功 验证docker版本：sudo docker version 测试：sudo docker run hello-world docker配置： 创建docker用户组 sudo groupadd docker 增加当前用户到docker分组 sudo usermod -aG docker dajiangtai 验证在不使用sudo的情况下docker是否正常工作 docker run hello-world 设置docker开机启动 sudo chkconfig docker on docker卸载 查看安装包 yum list installed | grep docker 移除安装包： sudo yum -y remove docker-engine.x86_64 清除所有docker依赖文件 rm -rf /var/lib/docker 删除用户创建的配置文件 Docker的核心概念Docker核心概念之镜像: Docker 镜像就是一个只读的模板。 例如：一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。 镜像可以用来创建 Docker 容器。 创建Docker镜像有几种方式，多数是在一个现有镜像基础上创建新镜像，因为几乎你需要的任何东西都有了公共镜像，包括所有主流Linux发行版，你应该不会找不到你需要的镜像。不过，就算你想从头构建一个镜像，也有好几种方法。 要创建一个镜像，你可以拿一个镜像，对它进行修改来创建它的子镜像 。 Docker核心概念之容器 Docker 利用容器来运行应用。 容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 注：镜像是只读的，容器在启动的时候创建一层可写层作为最上层。 Docker核心概念之仓库 仓库是集中存放镜像文件的场所。 有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。","excerpt":"","categories":[{"name":"docker","slug":"docker","permalink":"http://asion.club/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://asion.club/tags/docker/"}]},{"title":"（一）Docker Overview","date":"2017-05-24T09:00:11.000Z","path":"posts/docker/docker-001-overview.html","text":"初识docker1.什么是dockerDocker 是一个开源项目，诞生于 2013 年初，最初是 dotCloud 公司内部的一个业余项目。它基于 Google 公司推出的 Go 语言实现。 项目后来加入了 Linux 基金会，遵从了 Apache 2.0 协议，项目代码在 GitHub 上进行维护。Docker 自开源后受到广泛的关注和讨论，以至于 dotCloud 公司后来都改名为 Docker Inc。Redhat 已经在其 RHEL6.5 中集中支持 Docker；Google 也在其 PaaS 产品中广泛应用。 Docker的主要目标：通过对应用组件的封装、分发、部署、运行等生命周期的管理，达到应用级别的一次封装，到处运行；小贴士：这里的应用组件，可以是WEB应用，也可以是一套数据库服务，甚至可以是一个操作系统编译器 2.为什么使用dockerDocker容器虚拟化的优点： 环境隔离； 通过cgroups和namesapce进行实现资源隔离，实现一台机器运行多个容器互不影响。 更快速的交付部署； 使用docker，开发人员可以利用镜像快速构建一套标准的研发环境；开发完成后，测试和运维人员可以直接通过使用相同的环境来部署代码。Docker可以快速创建和删除容器，实现快速迭代，大量节约开发、测试、部署的时间。并且，各个步骤都有明确的配置和操作，整个过程全程课件，使团队里更容易理解应用创建和工作的过程。 更高效的资源利用； docker容器的运行不需要额外的虚拟化管理程序的支持，它是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。 更易迁移扩展； docker容器几乎可以在任意的平台上运行，包括乌力吉、虚拟机、公有云、私有云、个人电脑、服务器等，这种兼容性让用户可以在不同平台之间轻松的迁移应用。 更简单的更新管理。 使用Dockerfile,只需要小小的配置修改，就可以替代以往的大量的更新工作。并且所有修改都是以增量的方式进行分发和更新，从而实现自动化和高效的容器管理。 3.虚拟化与docker虚拟化定义：虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以比原本的配置更好的方式来应用这些资源。这些资源的新虚拟部分是不受现有资源的架设方式，地域或物理配置所限制。一般所指的虚拟化资源包括计算能力和数据存储。 系统虚拟化，Hypervisor Virtualization，全虚拟化。在 Host 中通过 Hypervisor 层实现安装多个 GuestOS，每个 GuestOS 都有自己的内核，和主机的内核不同，GuestOS 之间完全隔离。 容器虚拟化，Operating System Virtualization ，使用 Linux 内核中的 namespaces 和 cgroups 实现进程组之间的隔离。是用内核技术实现的隔离，所以它是一个共享内核的虚拟化技术。 容器虚拟化没有 GuestOS，使用 Docker 时下载的镜像，只是为运行 App 提供的一个依赖的环境，是一个删减版本的系统镜像。一般情况下系统虚拟化没有容器虚拟化的运行效率高，但是系统安全性高很多。","excerpt":"","categories":[{"name":"docker","slug":"docker","permalink":"http://asion.club/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://asion.club/tags/docker/"}]},{"title":"JUnit Tutorial 系列教程(一) JUnit概述","date":"2017-03-24T02:07:23.000Z","path":"posts/testing/junit-totulrial-s1-001-index.html","text":"JUnit 系列教程(一) JUnit概述&emsp;&emsp;JUnit是Java编程语言的单元测试框架。JUnit在测试驱动开发中一直很重要，它起源于统称为xUnit的单元测试框架。 Overview&emsp;&emsp;软件测试是检查应用程序的功能确保其按照要求运行的过程。单元测试是在开发层面的；它是单个个体（类或方法）的测试。单元测试对于提高软件质量有着重要的帮助，在帮助软件公司向客户提供优质的产品方面发挥关键作用。单元测试可以通过两种方式进行： 手动测试：在没有任何工具支持的情况下手动执行测试用例称为手动测试。 自动测试：使用自动化工具进行工具支持和执行测试用例称为自动化测试。 两种方式对比： 手动测试 自动测试 耗时和乏味 - 由于测试用例是由人力资源执行的，所以非常慢而繁琐。 快速 - 自动化运行测试用例明显快于人力资源。 对人力资源的巨大投入 - 由于测试用例需要手动执行，所以在手动测试中需要更多的测试人员。 减少对人力资源的投入 - 使用自动化工具执行测试用例，因此在自动化测试中需要较少的测试人员。 不太可靠 - 手动测试不太可靠，因为它必须解决人为错误。 更可靠 - 自动化测试精确可靠。 不可编程 - 无需编写可编写复杂测试来获取隐藏信息的编程。 可编程 - 测试人员可以对复杂的测试进行编程，以提供隐藏的信息。 什么是JUnit？&emsp;&emsp;JUnit是Java编程语言的单元测试框架。它是测试驱动开发中的关键角色，并且是统称为xUnit的单元测试框架系列。&emsp;&emsp;JUnit提出了“首先测试然后编码”的想法，其强调为首先测试然后实现的一段代码设置测试数据。这种方法就像“测试一点，代码一点，测试一点，代码一点”。它提高了程序员的生产力和程序代码的稳定性，从而降低了程序员的压力和调试时间。 JUnit的特性 JUnit是一个开源框架，开源社区活跃。 提供注解的方式来识别测试方法。 提供用于测试预期结果的断言。 提供运行测试的测试Runner。 JUnit测试允许您更快地编写代码，从而提高质量。 JUnit优雅简单。它不那么复杂，花费更少的时间。 JUnit测试可以自动运行，并检查自己的结果并提供即时反馈。没有必要手动梳理测试结果的报告。 JUnit测试可以组织成包含测试用例的测试套件，甚至其他测试套件。 如果测试运行平稳，JUnit会显示一个绿色的测试进度，当测试失败时，它会变为红色。 什么是单元测试用例？&emsp;&emsp;单元测试用例是代码的一部分，可以确保代码（方法）的另一部分按预期工作。为了快速实现所需的结果，需要一个测试框架。JUnit是Java编程语言的完美单元测试框架。&emsp;&emsp;正式的书面单元测试用例的特征在于已知的输入和预期的输出，在测试执行之前计算出来。已知输入应测试前提条件，预期输出应测试后期条件。&emsp;&emsp;每个要求必须至少有两个单元测试用例 - 一个正测试和一个负测试。如果要求有次级要求，则每个子要求必须至少有两个测试用例为正值和负数。 第一个测试用例12345678public class FirstJUnitTestCase &#123; @Test public void testString() &#123; String str = \"JUnut 已经成功运行！\"; // 断言String是否相等 assertEquals(\"JUnut 已经成功运行！\", str); &#125;&#125;","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://asion.club/categories/java/"},{"name":"testing","slug":"java/testing","permalink":"http://asion.club/categories/java/testing/"}],"tags":[{"name":"java","slug":"java","permalink":"http://asion.club/tags/java/"},{"name":"testing","slug":"testing","permalink":"http://asion.club/tags/testing/"},{"name":"junit","slug":"junit","permalink":"http://asion.club/tags/junit/"}]},{"title":"Java leaning road 从菜佳娃到佳娃假购师","date":"2017-03-21T13:48:57.000Z","path":"posts/java/java-leaning-road.html","text":"Java学习之路 从菜佳娃–&gt;佳娃假购师","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://asion.club/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://asion.club/tags/java/"}]},{"title":"道德经","date":"2017-01-17T07:31:36.000Z","path":"posts/life/my-life-way.html","text":"道德经我们是谁 第一章 道, 可道非常道; 名, 可名非常名 无, 名天地之始; 有, 名万物之母 故常无欲以观其妙。常有欲以观其徼。此两者同出而异名，同谓之玄。玄之又玄，众妙之门。 天下皆知美之为美，斯恶矣；皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相 倾，音声相和，前後相随。是以圣人处无为之事，行不言之教。万物作焉而不辞。生而不有，为而不恃， 功成而弗居。夫唯弗居，是以不去。 不尚贤， 使民不争。不贵难得之货，使民不为盗。不见可欲，使民心不乱。是以圣人之治，虚其心， 实其腹，弱其志，强其骨；常使民无知、无欲，使夫智者不敢为也。为无为，则无不治。 道冲而用之，或不盈。渊兮似万物之宗。解其纷，和其光，同其尘，湛兮似或存。吾不知谁之子，象 帝之先。 05.天地不仁，以万物为刍狗。圣人不仁，以百姓为刍狗。天地之间，其犹橐迭乎？虚而不屈，动而愈出 。多言数穷，不如守中。 06.谷神不死是谓玄牝。玄牝之门是谓天地根。绵绵若存，用之不勤。 07.天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人後其身而身先，外其身而身存。 非以其无私邪！故能成其私。 08.上善若水。水善利万物而不争，处众人之所恶，故几於道。居善地，心善渊，与善仁，言善信，正善 治，事善能，动善时。夫唯不争，故无尤。 09.持而盈之不如其己；揣而锐之不可长保；金玉满堂莫之能守；富贵而骄，自遗其咎。功遂身退，天之 道。 10.载营魄抱一，能无离乎？专气致柔，能如婴儿乎？涤除玄览，能无疵乎？爱国治民，能无为乎？天门 开阖，能为雌乎？明白四达，能无知乎。 我们从哪里来11.三十幅共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室 之用。故有之以为利，无之以为用。 12.五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨。是以圣人 ，为腹不为目，故去彼取此。 13.宠辱若惊，贵大患若身。何谓宠辱若惊？宠为下。得之若惊失之若惊是谓宠辱若惊。何谓贵大患若身 ？吾所以有大患者，为吾有身，及吾无身，吾有何患。故贵以身为天下，若可寄天下。爱以身为天下，若 可托天下。 14.视之不见名曰夷。听之不闻名曰希。抟之不得名曰微。此三者不可致诘，故混而为一。其上不皦 (jiǎo)，其下不昧，绳绳不可名，复归於无物。是谓无状之状，无物之象，是谓惚恍。迎之不见其首，随 之不见其後。执古之道以御今之有。能知古始，是谓道纪。 15.古之善为士者，微妙玄通，深不可识。夫唯不可识，故强为之容。豫兮若冬涉川；犹兮若畏四邻；俨 兮其若容；涣兮若冰之将释；敦兮其若朴；旷兮其若谷；混兮其若浊；澹兮其若海；飉(liáo,风的声音)兮 若无止。孰能浊以静之徐清。孰能安以动之徐生。保此道者不欲盈。夫唯不盈故能蔽而新成。 16.致虚极守静笃。万物并作，吾以观复。夫物芸芸各复归其根。归根曰静，是谓复命；复命曰常，知常 曰明。不知常，妄作凶。知常容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。 17.太上，下知有之。其次，亲而誉之。其次，畏之。其次，侮之。信不足焉，有不信焉。悠兮其贵言， 功成事遂，百姓皆谓∶我自然。 18.大道废有仁义；慧智出有大伪；六亲不和有孝慈；国家昏乱有忠臣。 19.绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有；此三者，以为文不足。故令有所 属，见素抱朴少私寡欲。 20.绝学无忧，唯之与阿，相去几何？善之与恶，相去若何？人之所畏，不可不畏。荒兮其未央哉！众人 熙熙如享太牢、如春登台。我独泊兮其未兆，如婴儿之未孩；儡儡(lěi,羸弱)兮若无所归。众人皆有馀，而 我独若遗。我愚人之心也哉！沌沌兮。俗人昭昭，我独昏昏；俗人察察，我独闷闷。众人皆有以，而我独 顽且鄙。我独异於人，而贵食母。 我们要到哪里去","excerpt":"","categories":[{"name":"life","slug":"life","permalink":"http://asion.club/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"http://asion.club/tags/life/"},{"name":"国学","slug":"国学","permalink":"http://asion.club/tags/国学/"}]},{"title":"Hexo Quick Start","date":"2016-10-26T20:56:25.000Z","path":"posts/hexo-quick-start.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","excerpt":"","categories":[{"name":"hexo","slug":"hexo","permalink":"http://asion.club/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://asion.club/tags/hexo/"}]},{"title":"Git版本控制与Git Flow工作流程","date":"2016-08-26T12:33:25.000Z","path":"posts/git-flow.html","text":"GIT版本控制与工作流程修订历史记录 日期：2016-08-26版本：0.1修订人：Asion Lu备注：修订版 引言编写的目的 通过规范化的流程，使得产品、开发与测试等各个部门更高效的协同工作。 通过规范化的流程使得产品高效稳定运行。 背景在多组员，多项目等环境进行协同工作时，如果没有统一规范、统一流程，则会导致额外的工作量，甚至会做无用功。所以要减少版本冲突，减轻不必要的工作，就需要规范化的工作流程。 总则 统一使用Git作为版本控制的主要工具。 统一使用GitFlow流程管理控制版本。 提交的准则 除了源码相关的东西之外，其他build产生的东西（如：maven的target文件夹，.idea文件夹等），均不能提交进入源码仓库，添加到.gitignore文件中忽略掉。 撰写规范的提交说明。一份好的提交说明可以帮助协作者更轻松更有效地配合工作。 要严格按照我们指定的流程切换到指定分支，开发相应的功能。 分支简述我们使用的分支流程： 天蓝色圆点所在的线为我们源码的主线（master）。 天蓝色方形指向的节点就是每一个发布版本的标签（tag）。 紫色圆点所在的线为主要分支线（develop）。 橙色圆点所在的线为新功能开发分支线（feature）。 绿色圆点所在的线为新版本发布线（release）。 红色圆点所在的线为发布版本bug修复线（hotfix）。 主分支说明代替原来的单个主线（master），我们使用两个分支来记录源码轨迹： 原来的master分支用来记录官方发布轨迹； 新的develop分支是一个集成分支，用来记录开发新功能的轨迹。除了master主线和develop主分支线，其他的分支都是临时的分支，有一定的生命周期的，其余的工作流程分支都是围绕这两个分支之间的区别进行的。 其他分支说明 新功能分支（Feature Branches） 每一个新的功能都应该创建一个独立的分支，从develop分支中派生出来。当功能完成后，要合并（merged）回develop分支，合并后它的生命周期就结束。新功能分支不会与master分支有直接的交汇。如图： 注意：对于所有意图和目的，新功能分支会合并到develop分支。但是，这个Gitflow工作流不会在此结束。 发布分支（Release Branches） 一旦开发的功能已经满足发布条件（或预定发布日期接近），应该合并所有满足发布条件的新功能分支到develop分支中，然后，开出一个发布分支（Release），开始准备一个发布版本。在这个分支上，不能再添加新的功能，只有bug修复和该版本为导向的任务。一旦到了发布日期，Release就要合并回master发布，并且，打出版本标签。另外，还需要合并回develop分支。 使用一个专门的分支来准备发布版本，使得一个团队能对当前版本进行抛光，而另一个团队继续为下一个版本的功能做准备。它还创造了良好定义的发展阶段（例如，很容易说，“本周我们正在准备4.0版”，而且真实地看到它在库中的结构）。 维护分支（Maintenance Branches） 维护分支也就是线上bug修复分支，使用来快速修复生产环境的紧急问题。 这个分支是唯一一个开放过程中直接从master分支派生来的分支。快速的修复问题后，它应该被合并回master和develop（或者当前发布分支），然后，master分支需要打一个版本标签。 一个专门的错误修复开发线，可以让团队在不等待下一个发布周期，导致中断工作流程情况下解决问题。可以将维护分支当做主要的问题修复分支，与master并行。 命名约定 主分支名称：master 主开发分支名称：develop 标签（tag）名称：v*.RELEASE，其中”*“ 为版本号，“RELEASE”大写，如：v1.0.0.RELEASE 新功能开发分支名称：feature-* or feature/*，其中“*” 为新功能简述，如：feature-item-activity-list 发布分支名称：release-* or release/*，其中* 为版本号，“release”小写，如：release-1.0.0 master的bug修复分支名称：hotfix-* or hotfix/* ，其中* 为bug简述，如：hotfix/item-update-bug工作流程下面具体演示如何使用工作流来管理版本发布周期。假设我们已经存在或创建了一个源码中央存储仓库。 工作流的基础创建develop分支 项目负责人在本地master基础上创建一个develop分支，然后，推送到服务器； 12git branch developgit push -u origin develop 其他开发人员，需要克隆develop中央仓库的源码，创建一个develop的轨迹版本；如果，已经克隆过该项目，则，不需要执行以下第一条命令。 12git clone git@bitbucket.org:ytx-dev/ytx-demo.gitgit checkout -b develop origin/develop develop这个分支将包含项目的完整历史记录，而master将包含缩略版本。 假设开始以下所有的流程之前，都已经创建好develop分支。 新功能开发流程 新建feature分支 基于develop分支创建新功能分支： 1git checkout -b feature/demo develop 推送到远程仓库，共享： 1git push 所有开发此新功能的人员，都在此分支上开发提交代码。 123git statusgit add &lt;some-file&gt;git commit -m \"Add some-file.\" 完成新功能开发（合并feature分支到develop） 当确定新功能开发完成，且联调测试通过，并且新功能负责人已经得到合并feature分支到develop分支的允许；这样才能合并feature分支到develop。 12345git pull origin develop git checkout developgit merge feature/demogit pushgit branch -d feature/demo 第一条命令是确保在合并新功能之前，develop分支是最新的。 注意： 新功能分支，永远不要直接合并到master分支。 合并可能会有冲突，应该谨慎处理冲突。 在测试环境发布develop分支代码（提交测试） 线上版本发布流程 从develop中创建准备发布的release分支 当主测试流程完成，源码已经趋近于稳定状态，应该准备一个发布版本，确立版本号： 1git checkout -b release-0.1.0 develop 推送到远程仓库共享： 1git push 这个分支是清理准备发布、 整体回归测试、 更新文档，和做其他任何系统即将发布的事情。 继续抛光改bug release分支合并到master发布 一旦已经满足发布条件（或已经到了预定发布日期），应该把release分支合并到master分支和develop分支中，然后，使用master发布新版本。合并release分支到develop分支是很重要的，要让release上修改的东西能在后续的开发分支中生效。 123git checkout mastergit merge release-0.1.0git push release分支合并到develop 1234 git checkout developgit merge release-0.1.0git pushgit branch -d release-0.1.0 打标签 Release分支在功能开发分支（develop）和公共发布版（master）中，充当一个缓冲的作用。每当有源码合并到master中的时候，应该在master上打一个标签，以便后续跟踪查阅。 12git tag -a 0.1.0.RELEASE -m \"Initial public release\" mastergit push --tags 线上Bug修复流程当终端用户，反馈系统有bug时，为了处理bug，需要从master中创建出保养分支；等到bug修复完成，需要合并回master： 创建hotfix分支 1git checkout -b issue-#001 master 修改bug Fix the bug 完成修复，合并到master发布 123git checkout mastergit merge issue-#001git push 打标签 12git tag -a 0.1.1.RELEASE -m \"Initial public release\" mastergit push --tags 合并到develop 123git checkout developgit merge issue-#001git push 其他附录参考资料 git-book what-is-version-control gitflow-workflow","excerpt":"","categories":[{"name":"VCS","slug":"VCS","permalink":"http://asion.club/categories/VCS/"},{"name":"git","slug":"VCS/git","permalink":"http://asion.club/categories/VCS/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://asion.club/tags/git/"},{"name":"git-flow","slug":"git-flow","permalink":"http://asion.club/tags/git-flow/"},{"name":"VCS","slug":"VCS","permalink":"http://asion.club/tags/VCS/"}]}]